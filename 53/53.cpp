leetcode 53, 找出sum最大的连续子数组
[-2,1,-3,4,-1,2,1];
-----------------------
|   |  0 |  1 |  2 | 3 |  4 | 5 | 6 |   |   |
|---+----+----+----+---+----+---+---+---+---|
| 1 | -2 |  1 | -3 | 4 | -1 | 2 | 1 |   |   |
| 2 | -1 | -2 |  1 | 3 |  1 | 3 |   |   |   |
| 3 | -4 |  2 |  0 | 5 |  2 |   |   |   |   |
| 4 |    |    |    |   |    |   |   |   |   |
| 5 |    |    |    |   |    |   |   |   |   |
| 6 |    |    |    |   |    |   |   |   |   |
| 7 |    |    |    |   |    |   |   |   |   |
|   |    |    |    |   |    |   |   |   |   |
|   |    |    |    |   |    |   |   |   |   |
表格元素含义: 行 ---> 子数组的元素个数, 列 ---> 子数组是从原数组中的哪个index开始的;

       //当j = 3, i = 3时， sum = sums[i - 1][j] + nums[j + i - 1];

-----------------------
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int size = nums.size();
        if (size == 0)
            return 0;
        std::vector<int> vec(size, 0);
        std::vector<std::vector<int>> sums(size + 1, vec);
        int maxSum = INT_MIN;
        for (int i = 1; i <= size; ++i)
        {
            for (int j = 0; j <= size - i; ++j)
            {
                // int sum = std::accumulate(nums.begin() + j, nums.begin() + j + i, 0);
                int sum = sums[i - 1][j] + nums[j + i - 1];
                sums[i][j] = sum;
                maxSum = std::max(maxSum, sum);
            }
        }
        return maxSum;
    }
};
--------------------------------------------------
[-2,1,-3,4,-1,2,1];
|  0 | 1 |  2 | 3 | 4 | 5 | 6 |   |   |   |
|----+---+----+---+---+---+---+---+---+---|
| -2 | 1 | -2 | 4 | 3 | 5 | 6 |   |   |   |
|    |   |    |   |   |   |   |   |   |   |
1. 子问题设定: 它是以原数组第0个元素开始，以第i个元素结束的子数组的sum的最大子数组
2. i = 1 ---> [-2, 1] ---> [1] ---> sum = 1;
3. i = 2 ---> [-2, 1, -3] ---> 1 + (-3) = -2;
